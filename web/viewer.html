<!DOCTYPE html> 

<html lang="it"> 

<head> 

  <meta charset="utf-8" /> 

  <title>PDF Viewer con Text Layer + Link precisi</title> 

  <meta name="viewport" content="width=device-width, initial-scale=1" /> 

  <style> 

    html, body { 

      margin: 0; padding: 0; height: 100%; background: #fff; 

      font-family: sans-serif; 

      overflow: auto; 

    } 

    #pdf-container { 

      width: 100%; 

      max-width: 900px; 

      margin: 0 auto; 

      padding: 20px 0; 

    } 

    .page-wrapper { 

      position: relative; 

      margin-bottom: 20px; 

      box-shadow: 0 0 8px rgba(0,0,0,0.1); 

    } 

    canvas { 

      display: block; 

      width: 100%; 

      height: auto; 

    } 

    .text-layer { 

      position: absolute; 

      top: 0; left: 0; 

      color: transparent; 

      transform-origin: 0 0; 

      line-height: 1; 

      z-index: 20; 

      pointer-events: none; 

    } 

    .text-layer span { 

      position: absolute; 

      white-space: pre; 

      transform-origin: 0 0; 

      pointer-events: auto; 

      color: black; /* Se vuoi vedere il testo vero, se no metti transparent */ 

    } 

    .text-layer span.link { 

      text-decoration: underline; 

      color: blue; 

      cursor: pointer; 

    } 

  </style> 

</head> 

<body> 

 

<div id="pdf-container"></div> 

 

<script type="module"> 

  import * as pdfjsLib from '../build/pdf.mjs'; 

 

  pdfjsLib.GlobalWorkerOptions.workerSrc = '../build/pdf.worker.mjs'; 

 

  const url = '../docs/file.pdf'; 

  const container = document.getElementById('pdf-container'); 

 

  pdfjsLib.getDocument(url).promise.then(async (pdf) => { 

    console.log(`PDF caricato: ${pdf.numPages} pagine`); 

 

    async function resolveDestination(dest) { 

      if (typeof dest === 'string') { 

        return pdf.getDestination(dest); 

      } 

      return dest; 

    } 

 

    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) { 

      const page = await pdf.getPage(pageNum); 

      await renderPage(page); 

    } 

 

    async function scrollToPage(pageNum, offsetY = 0) { 

      if (pageNum >= 1 && pageNum <= pdf.numPages) { 

        const wrapper = container.children[pageNum - 1]; 

        if (wrapper) { 

          const top = wrapper.offsetTop + offsetY; 

          window.scrollTo({ 

            top: top, 

            behavior: 'smooth' 

          }); 

        } 

      } 

    } 

 

    window.addEventListener('hashchange', () => { 

      const m = location.hash.match(/#page=(\d+)/); 

      if (m) scrollToPage(parseInt(m[1], 10)); 

    }); 

 

    const initialMatch = location.hash.match(/#page=(\d+)/); 

    if (initialMatch) { 

      setTimeout(() => { 

        scrollToPage(parseInt(initialMatch[1], 10)); 

      }, 500); 

    } 

 

    async function renderPage(page) { 

      const viewport = page.getViewport({ scale: 1.5 }); 

 

      const pageWrapper = document.createElement('div'); 

      pageWrapper.className = 'page-wrapper'; 

 

      const canvas = document.createElement('canvas'); 

      const ctx = canvas.getContext('2d'); 

      canvas.width = viewport.width; 

      canvas.height = viewport.height; 

 

      pageWrapper.appendChild(canvas); 

      container.appendChild(pageWrapper); 

 

      await page.render({ canvasContext: ctx, viewport: viewport }).promise; 

 

      // TEXT LAYER 

      const textContent = await page.getTextContent(); 

      const textLayerDiv = document.createElement('div'); 

      textLayerDiv.className = 'text-layer'; 

      textLayerDiv.style.width = canvas.width + 'px'; 

      textLayerDiv.style.height = canvas.height + 'px'; 

      pageWrapper.appendChild(textLayerDiv); 

 

      textContent.items.forEach(async (textItem) => { 

        const tx = pdfjsLib.Util.transform( 

          viewport.transform, 

          textItem.transform 

        ); 

 

        const style = textContent.styles[textItem.fontName]; 

 

        const span = document.createElement('span'); 

        span.textContent = textItem.str; 

 

        const fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]); 

        span.style.fontSize = fontHeight + 'px'; 

 

        const scaleX = Math.sqrt(tx[0] * tx[0] + tx[1] * tx[1]); 

 

        span.style.transform = `translate(${tx[4]}px, ${tx[5]}px) scaleX(${scaleX})`; 

        span.style.transformOrigin = 'left bottom'; 

 

        // LINK interno 

        if (textItem.hasOwnProperty('annotation') && textItem.annotation.dest) { 

          span.classList.add('link'); 

 

          const dest = await resolveDestination(textItem.annotation.dest); 

          if (dest && dest[0]) { 

            const pageRef = dest[0]; 

            const pageIndex = await pdf.getPageIndex(pageRef); 

            const targetPageNum = pageIndex + 1; 

 

            let offsetY = 0; 

 

            if (dest[1]?.name === 'FitR') { 

              const targetX = dest[2]; 

              const targetY = dest[5]; 

 

              const targetViewport = (await pdf.getPage(targetPageNum)).getViewport({ scale: 1.5 }); 

              const [, , , scaleY, , offsetYInViewport] = targetViewport.transform; 

              const canvasHeight = targetViewport.height; 

              const viewportY = canvasHeight - targetY * scaleY; 

              offsetY = viewportY; 

            } 

 

            span.addEventListener('click', (e) => { 

              e.preventDefault(); 

              scrollToPage(targetPageNum, offsetY); 

              history.replaceState(null, '', `#page=${targetPageNum}`); 

            }); 

          } 

        } 

 

        textLayerDiv.appendChild(span); 

      }); 

    } 

  }); 

</script> 

 

</body> 

</html> 
