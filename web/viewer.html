<!DOCTYPE html> 

<html lang="it"> 

<head> 

  <meta charset="utf-8" /> 

  <title>PDF Viewer con link interni e FitR corretti</title> 

  <meta name="viewport" content="width=device-width, initial-scale=1" /> 

  <style> 

    html, body { 

      margin: 0; padding: 0; height: 100%; background: #fff; 

      font-family: sans-serif; 

      overflow: auto; 

    } 

    #pdf-container { 

      width: 100%; 

      max-width: 900px; 

      margin: 0 auto; 

      padding: 20px 0; 

    } 

    .page-wrapper { 

      position: relative; 

      margin-bottom: 20px; 

      box-shadow: 0 0 8px rgba(0,0,0,0.1); 

    } 

    canvas { 

      display: block; 

      width: 100%; 

      height: auto; 

    } 

    .link-layer { 

      position: absolute; 

      top: 0; left: 0; 

      pointer-events: none; 

      z-index: 10; 

    } 

    .link-layer a { 

      position: absolute; 

      display: block; 

      pointer-events: auto; 

      background: rgba(255, 0, 0, 0.05); /* per debug, puoi mettere 0.0 se non vuoi vedere */ 

    } 

  </style> 

</head> 

<body> 

 

<div id="pdf-container"></div> 

 

<script type="module"> 

  import * as pdfjsLib from '../build/pdf.mjs'; 

 

  pdfjsLib.GlobalWorkerOptions.workerSrc = '../build/pdf.worker.mjs'; 

 

  const url = '../web/compressed.tracemonkey-pldi-09.pdf'; 

  const container = document.getElementById('pdf-container'); 

 

  pdfjsLib.getDocument(url).promise.then(async (pdf) => { 

    console.log(`PDF caricato: ${pdf.numPages} pagine`); 

 

    async function resolveDestination(dest) { 

      if (typeof dest === 'string') { 

        return pdf.getDestination(dest); 

      } 

      return dest; 

    } 

 

    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) { 

      const page = await pdf.getPage(pageNum); 

      await renderPage(page); 

    } 

 

    async function scrollToPage(pageNum, offsetY = 0) { 

      if (pageNum >= 1 && pageNum <= pdf.numPages) { 

        const wrapper = container.children[pageNum - 1]; 

        if (wrapper) { 

          const top = wrapper.offsetTop + offsetY; 

          window.scrollTo({ 

            top: top, 

            behavior: 'smooth' 

          }); 

        } 

      } 

    } 

 

    window.addEventListener('hashchange', () => { 

      const m = location.hash.match(/#page=(\d+)/); 

      if (m) scrollToPage(parseInt(m[1], 10)); 

    }); 

 

    const initialMatch = location.hash.match(/#page=(\d+)/); 

    if (initialMatch) { 

      setTimeout(() => { 

        scrollToPage(parseInt(initialMatch[1], 10)); 

      }, 500); 

    } 

 

    async function renderPage(page) { 

      const viewport = page.getViewport({ scale: 1.5 }); 

 

      const pageWrapper = document.createElement('div'); 

      pageWrapper.className = 'page-wrapper'; 

 

      const canvas = document.createElement('canvas'); 

      const ctx = canvas.getContext('2d'); 

      canvas.width = viewport.width; 

      canvas.height = viewport.height; 

 

      pageWrapper.appendChild(canvas); 

      container.appendChild(pageWrapper); 

 

      await page.render({ canvasContext: ctx, viewport: viewport }).promise; 

 

      const annotations = await page.getAnnotations(); 

 

      const linkLayer = document.createElement('div'); 

      linkLayer.className = 'link-layer'; 

      linkLayer.style.width = canvas.width + 'px'; 

      linkLayer.style.height = canvas.height + 'px'; 

 

      pageWrapper.appendChild(linkLayer); 

 

      annotations.forEach(async (annotation) => { 

        if (annotation.subtype === 'Link' && annotation.dest) { 

          const rect = pdfjsLib.Util.normalizeRect(annotation.rect); 

 

          // ✅ Usa la funzione corretta per convertire coordinate PDF → viewport 

          const [x1, y1] = viewport.convertToViewportPoint(rect[0], rect[1]); 

          const [x2, y2] = viewport.convertToViewportPoint(rect[2], rect[3]); 

 

          const left = Math.min(x1, x2); 

          const top = Math.min(y1, y2); 

          const width = Math.abs(x2 - x1); 

          const height = Math.abs(y2 - y1); 

 

          console.log('Link annotation:', annotation.dest); 

 

          const link = document.createElement('a'); 

          link.style.left = `${left}px`; 

          link.style.top = `${top}px`; 

          link.style.width = `${width}px`; 

          link.style.height = `${height}px`; 

 

          const dest = await resolveDestination(annotation.dest); 

          if (dest && dest[0]) { 

            const pageRef = dest[0]; 

            const pageIndex = await pdf.getPageIndex(pageRef); 

            const targetPageNum = pageIndex + 1; 

 

            let offsetY = 0; 

 

            if (dest[1]?.name === 'FitR') { 

              // Calcola offsetY per FitR 

              const targetX = dest[2]; 

              const targetY = dest[5]; // Y bottom in PDF space 

 

              const targetViewport = (await pdf.getPage(targetPageNum)).getViewport({ scale: 1.5 }); 

 

              const [, , , scaleY, , offsetYInViewport] = targetViewport.transform; 

 

              const canvasHeight = targetViewport.height; 

              const viewportY = canvasHeight - targetY * scaleY; 

 

              offsetY = viewportY; 

            } 

 

            link.href = `#page=${targetPageNum}`; 

            link.addEventListener('click', (e) => { 

              e.preventDefault(); 

              scrollToPage(targetPageNum, offsetY); 

              history.replaceState(null, '', `#page=${targetPageNum}`); 

            }); 

          } 

 

          linkLayer.appendChild(link); 

        } 

      }); 

    } 

  }); 

</script> 

 

</body> 

</html> 
