<!DOCTYPE html> 

<html lang="it"> 

<head> 

  <meta charset="utf-8" /> 

  <title>PDF Viewer con link interni - compatibile mobile</title> 

  <meta name="viewport" content="width=device-width, initial-scale=1" /> 

  <style> 

    html, body { 

      margin: 0; padding: 0; height: 100%; background: #fff; 

      font-family: sans-serif; 

      overflow: auto; 

    } 

    #pdf-container { 

      width: 100%; 

      max-width: 900px; 

      margin: 0 auto; 

      padding: 20px 0; 

    } 

    .page-wrapper { 

      position: relative; 

      margin-bottom: 20px; 

      box-shadow: 0 0 8px rgba(0,0,0,0.1); 

      touch-action: manipulation; /* importante anche qui */ 

    } 

    canvas { 

      display: block; 

      width: 100%; 

      height: auto; 

      touch-action: none; /* evitare che il canvas blocchi i tap sui link */ 

    } 

    .link-layer { 

      position: absolute; 

      top: 0; left: 0; 

      width: 100%; 

      height: 100%; 

      pointer-events: auto; 

      z-index: 10; 

      touch-action: manipulation; 

    } 

    .link-layer a { 

      position: absolute; 

      display: block; 

      pointer-events: auto; 

      background: rgba(255, 255, 255, 0); /* trasparente per mobile */ 

      touch-action: manipulation; 

    } 

  </style> 

</head> 

<body> 

 

<div id="pdf-container"></div> 

 

<script type="module"> 

  import * as pdfjsLib from '../build/pdf.mjs'; 

 

  pdfjsLib.GlobalWorkerOptions.workerSrc = '../build/pdf.worker.mjs'; 

 

  const url = '../web/compressed.tracemonkey-pldi-09.pdf'; 

  const container = document.getElementById('pdf-container'); 

 

  let currentPageShown = null; 

 

  pdfjsLib.getDocument(url).promise.then(async (pdf) => { 

    console.log(`PDF caricato: ${pdf.numPages} pagine`); 

 

    async function resolveDestination(dest) { 

      if (typeof dest === 'string') { 

        return pdf.getDestination(dest); 

      } 

      return dest; 

    } 

 

    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) { 

      const page = await pdf.getPage(pageNum); 

      await renderPage(page); 

    } 

 

    function scrollToPage(pageNum) { 

      if (pageNum >= 1 && pageNum <= pdf.numPages) { 

        const wrapper = container.children[pageNum - 1]; 

        if (wrapper) { 

          wrapper.scrollIntoView({ behavior: 'smooth' }); 

          currentPageShown = pageNum; 

        } 

      } 

    } 

 

    window.addEventListener('hashchange', () => { 

      const m = location.hash.match(/#page=(\d+)/); 

      if (m) { 

        const pageNum = parseInt(m[1], 10); 

        if (pageNum !== currentPageShown) { 

          scrollToPage(pageNum); 

        } 

      } 

    }); 

 

    const initialMatch = location.hash.match(/#page=(\d+)/); 

    if (initialMatch) { 

      setTimeout(() => { 

        scrollToPage(parseInt(initialMatch[1], 10)); 

      }, 500); 

    } 

 

    function applyTransform([x, y], transform) { 

      const [a, b, c, d, e, f] = transform; 

      return [ 

        a * x + c * y + e, 

        b * x + d * y + f, 

      ]; 

    } 

 

    async function renderPage(page) { 

      const viewport = page.getViewport({ scale: 1.5 }); 

 

      const pageWrapper = document.createElement('div'); 

      pageWrapper.className = 'page-wrapper'; 

 

      const canvas = document.createElement('canvas'); 

      const ctx = canvas.getContext('2d'); 

      canvas.width = viewport.width; 

      canvas.height = viewport.height; 

 

      pageWrapper.appendChild(canvas); 

      container.appendChild(pageWrapper); 

 

      await page.render({ canvasContext: ctx, viewport: viewport }).promise; 

 

      const annotations = await page.getAnnotations(); 

 

      const linkLayer = document.createElement('div'); 

      linkLayer.className = 'link-layer'; 

      linkLayer.style.width = canvas.clientWidth + 'px'; 

      linkLayer.style.height = canvas.clientHeight + 'px'; 

 

      pageWrapper.appendChild(linkLayer); 

 

      const scaleX = canvas.clientWidth / canvas.width; 

      const scaleY = canvas.clientHeight / canvas.height; 

 

      annotations.forEach(async (annotation) => { 

        if (annotation.subtype === 'Link' && annotation.dest) { 

          const rect = pdfjsLib.Util.normalizeRect(annotation.rect); 

 

          const [x1, y1] = applyTransform([rect[0], rect[1]], viewport.transform); 

          const [x2, y2] = applyTransform([rect[2], rect[3]], viewport.transform); 

 

          const left = Math.min(x1, x2) * scaleX; 

          const top = Math.min(y1, y2) * scaleY; 

          const width = Math.abs(x2 - x1) * scaleX; 

          const height = Math.abs(y2 - y1) * scaleY; 

 

          const link = document.createElement('a'); 

          link.style.left = `${left}px`; 

          link.style.top = `${top}px`; 

          link.style.width = `${width}px`; 

          link.style.height = `${height}px`; 

          link.style.pointerEvents = 'auto'; 

          link.style.background = 'rgba(255, 255, 255, 0)'; 

          link.style.touchAction = 'manipulation'; 

          link.setAttribute('role', 'button'); 

          link.setAttribute('aria-label', 'Vai alla pagina'); 

 

          link.href = '#'; 

 

          // span interno per garantire il click su mobile 

          link.innerHTML = '<span style="display:block;width:100%;height:100%;">&nbsp;</span>'; 

 

          const dest = await resolveDestination(annotation.dest); 

          if (dest && dest[0]) { 

            const pageRef = dest[0]; 

            const pageIndex = await pdf.getPageIndex(pageRef); 

            const targetPageNum = pageIndex + 1; 

 

            link.addEventListener('click', (e) => { 

              e.preventDefault(); 

              scrollToPage(targetPageNum); 

              history.replaceState(null, '', `#page=${targetPageNum}`); 

            }); 

          } 

 

          linkLayer.appendChild(link); 

        } 

      }); 

    } 

  }); 

</script> 

 

</body> 

</html> 
